use std::{
    fs::{copy, File},
    io::{BufRead, BufReader},
    path::PathBuf,
    process::Command,
};

use serenity::{
    model::{channel::Message, id::ChannelId},
    prelude::*,
};

use sysinfo::{DiskExt, System, SystemExt};

use eval::eval;

extern crate libc;

use libc::{c_int, pid_t};

pub mod commands {
    pub mod backup;
    pub mod execute;
    pub mod help;
    pub mod invalid;
    pub mod ping;
    pub mod recompile;
    pub mod script;
    pub mod sessions;
    pub mod syscheck;
}

// not so useful help message to printout when accessed from the command line
#[inline(always)]
pub fn print_help() {
    let help_msg = format!(
        "
       hypnos_core: chat bot, backup manager, and more
       Usage:
            hypnos_core
            hypnos_core <action> [option]
            hypnos_core <stop [all/<server>] | start [all/<server>]>
       Options:
            gen_cfg
            health
            backup [ls | rm] <backup>
       "
    );
    println!("{}", help_msg);
    std::process::exit(0);
}

// blame the extremely inconsistent formmatting of the log file in terraria for this mess
//
// plus I trust llvm to make my code less bad
//
// This removes all the formmating codes coming from MC chat and terraria
#[inline(always)]
fn replace_formatting(msg: String) -> String {
    msg.replace(&"ยง0", "")
        .replace(&"ยง1", "")
        .replace(&"ยง2", "")
        .replace(&"ยง3", "")
        .replace(&"ยง4", "")
        .replace(&"ยง5", "")
        .replace(&"ยง6", "")
        .replace(&"ยง7", "")
        .replace(&"ยง8", "")
        .replace(&"ยง9", "")
        .replace(&"ยงa", "")
        .replace(&"ยงb", "")
        .replace(&"ยงc", "")
        .replace(&"ยงd", "")
        .replace(&"ยงe", "")
        .replace(&"ยงf", "")
        .replace(&"ยงg", "")
        .replace(&"ยงk", "")
        .replace(&"ยงl", "")
        .replace(&"ยงm", "")
        .replace(&"ยงn", "")
        .replace(&"ยงo", "")
        .replace(&"ยงr", "")
        .replace("[6n", "")
        .replace("[39;49m", "")
        .replace(": <", "<")
        .replace("]: ", "")
        .replace(|c: char| !c.is_ascii(), "")
        .replace("_", "\\_")
}

// generate the tmux pipe connecting to the specified server, this also takes in the option to
// delete the file if it exists before generating it
// that can be used at startup or when just resetting the file in general
#[inline]
pub async fn gen_pipe(server_name: String, rm: bool) {
    if rm {
        // get the file path to the pipe file
        let pipe_old: String = format!("/tmp/{}-HypnosCore", &server_name);

        // remove the old pipe file if it exists
        if check_dir(pipe_old.to_owned(), true) {
            Command::new("rm")
                .arg(&pipe_old)
                .spawn()
                .expect("*error: failed to delete pipe file");
        }
    }

    // create the tmux command that will be entered to set the pipe
    let pipe_output = format!("cat >/tmp/{}-HypnosCore", &server_name);
    Command::new("tmux")
        .args(["pipe-pane", "-t", &server_name, &pipe_output])
        .spawn()
        .expect("*error: failed to generate pipe file");

    // call reap to remove any zombie processes generated by it
    reap();
}

// small function to send a command to the specific tmux session, this replaces new lines due to it
// causing a problem with commands
//
// this is one of the limitations of this system, but it's not that bad because if there are
// multiple lines you can send the command multiple times
#[inline(always)]
pub async fn send_command(server_name: String, message: String) {
    let msg = format!(
        "\"{}\"",
        &message
            .replace(|c: char| !c.is_ascii(), "")
            .replace("\\", ""),
    );

    Command::new("tmux")
        .args(["send-keys", "-t", &server_name, &msg, "Enter"])
        .spawn()
        .expect("*error: failed to send to tmux session");

    reap();
}

// function to check if the file or folder exist, if it does not exists emit a warning depending if
// the warning should be silenced or not
#[inline]
pub fn check_dir(dir: String, disable_warn: bool) -> bool {
    let current_path = PathBuf::from(&dir);
    if disable_warn == false && !current_path.exists() {
        println!("*error: {} does not exists!", dir);
    }
    return current_path.exists();
}

// checks the number of lines in the log file to set them initially, this prevents old messages
// from being spat out if the bot restarts (and makes it a lot less annoying)
pub fn set_lines(server_name: String) -> usize {
    let file_path: String = format!("/tmp/{}-HypnosCore", &server_name);
    let file = File::open(&file_path).unwrap();
    let reader = BufReader::new(file);

    // count the amount of lines in the log file
    reader.lines().count()
}

// function to handle mc commands send to a tmux session, this has a command "whitelist" to ensure
// that only certain commands are executed
async fn handle_command(server_name: String, cmd: String, arg: String) {
    let mut final_cmd = String::new();
    match &cmd[..] {
        "s" => final_cmd = format!("scoreboard objectives setdisplay sidebar {}", arg),
        "score" => final_cmd = format!("scoreboard objectives setdisplay sidebar {}", arg),
        _ => final_cmd = "list".to_string(),
    }
    send_command(server_name.to_owned(), final_cmd).await;
}

// update messages from the log file, this takes in the log file, checks if the lines can be
// ignored, then checks if the new lines are in game commands, if they are then use handle command
// to check them and if not send them to discord
//
// unfortunately this is not very efficient but honestly I don't really care, this runs on separate
// threads from the mc server and if the log file gets above 2k lines it gets repiped with tmux to
// prevent the function from taing too long
pub async fn update_messages(
    ign_prefix: String,
    server_name: String,
    lines: usize,
    ctx: Context,
    chat_id: u64,
) -> usize {
    let file_path: String = format!("/tmp/{}-HypnosCore", &server_name);

    if !check_dir(file_path.to_owned(), true) {
        return 0;
    }

    // open the log file in bufreader
    let file = File::open(&file_path).unwrap();
    let reader = BufReader::new(file);
    let mut message = "".to_string();

    let mut cur_line: usize = lines;

    // Read the file line by line using the lines() iterator from std::io::BufRead.
    for (i, line) in reader.lines().enumerate() {
        // skip lines that are irrelevant
        if i > cur_line {
            // if they are new, update the counter
            cur_line = i;

            let line = line.expect("failed to unwrap message");

            // if the line is too short then skip it
            if &line.chars().count() < &35 {
                continue;
            }

            // check if the message starts with certain characters
            let line_sep: &str = &line[33..];
            if !line.starts_with("[") || (!line_sep.starts_with("<") && !line_sep.starts_with("ยง"))
            {
                continue;
            }

            // check if it's an in game command
            let ign_command: String = format!("ยงr> {}", ign_prefix);

            // if it is, then check if it's in the command "whitelist"
            if line_sep.contains(&ign_command) {
                let allowed_commands: Vec<String> = vec!["s".to_string(), "score".to_string()];

                // parse where the actual command starts, without the username
                let cmd_start: usize = line_sep.find(&ign_command).unwrap() + 5;

                if line_sep.len() < cmd_start {
                    return cur_line;
                }

                // parse the actual command with argument
                let cmd: &str = &line_sep[cmd_start..];

                // parse where the just the command ends and where the argument is
                let cmd_split: Option<usize> = cmd.find(" ");

                if cmd_split.is_none() {
                    return cur_line;
                }

                // if it's in the whitelist send the command and argument separately to handle
                // command, there it will be transformed to the correct in game equivalent
                if allowed_commands.contains(
                    &cmd[1..cmd_split.expect("no command to split out of message")].to_owned(),
                ) {
                    handle_command(
                        server_name.to_owned(),
                        cmd[1..cmd_split.unwrap()].to_owned(),
                        cmd[(cmd_split.unwrap() + 1)..].to_owned(),
                    )
                    .await;
                }

                // update the line count in the main file and continue
                return cur_line;
            }

            let newline = &line[33..];

            if newline.len() < 1 {
                continue;
            }

            // if it's not an in game command, we can generate what the discord message will be
            //
            // firstly we put the server name then the new line message, this is where replace
            // formatting comes in to remove the special mc escape sequences
            let nmessage = format!(
                "[{}]{}\n",
                &server_name,
                &replace_formatting(newline.to_string())
            );

            message.push_str(&nmessage);
        }
    }

    if message.len() > 0 {
        // send the message to the chat bridge channel
        if let Err(why) = ChannelId(chat_id).say(&ctx.http, message).await {
            println!("Error sending message: {:?}", why);
        }
    }

    // if the lines are under 2k, we don't need to replace the file since it doesn't take much time
    // to process in the first place
    if lines < 2000 {
        return cur_line;
    }

    // if it is above 2k however, we can reset the pipe and notify the to the console
    gen_pipe(server_name.to_owned(), true).await;
    println!("*info: pipe file reset -> {}", server_name);

    // return new line count to update the one in the main file
    0
}

// similar to the function above, this checks for new messages that are not minecraft
// currently it only supports checking terraria servers due to the method of parsing, but that can
// be easily adjusted to work for any game or even normal processes
//
// terraria has a very wonky logging format, not everything that is logged goes to a new line, if
// the previous message was a command it changes format and if the previous was a message it
// changes the format back
//
// this inconsistency leads to the parsing pattern being highly inefficient
pub async fn update_messages_generic(
    server_name: String,
    lines: usize,
    ctx: Context,
    chat_id: u64,
    ll: String,
) -> (usize, String) {
    let file_path: String = format!("/tmp/{}-HypnosCore", &server_name);

    if !check_dir(file_path.to_owned(), true) {
        return (0, ll);
    }

    // open the log file in bufreader
    let file = File::open(&file_path).unwrap();
    let reader = BufReader::new(file);

    let mut fmessage = String::new();

    let mut cur_line: usize = lines;

    let mut new_line: String = String::new();

    // Read the file line by line using the lines() iterator from std::io::BufRead.
    for (i, line) in reader.lines().enumerate() {
        let line = line.expect("failed to unwrap message");

        // due to how the terraria log operates, it must keep a log of the last line and if the
        // current last line is the same do not send it, if it is different update the last line
        // and send it to discord
        if i >= cur_line {
            // if they are new, update the counter
            cur_line = i;

            new_line = line.to_owned();

            // these checks are very messy but very neccessary, the logging format of terraria is
            // highly inconsistent and this is one of the few ways to get it working
            if line.contains("<Server>")
                || line.contains("Saving world")
                || line.starts_with("Validating")
                || line.starts_with("Backing")
                || line.contains(" is connecting...")
                || line.contains(" was booted: ")
                || line.contains("[6nsay")
                || line.contains("say ->")
                || (line.contains("say ") && !line.contains(" say "))
                || line.contains("set a new record for ")                           /* support for modded terraria, this is filtering some of the messages the mods produce */
                || line.contains("Receiving boss records from the joined player")
                || line.len() < 8
                || &line == &ll
            {
                continue;
            }

            let reply: &str = &replace_formatting(line.to_string());

            if reply.len() < 1 {
                continue;
            }

            // if it's not an in game command, we can generate what the discord message will be
            //
            // firstly we put the server name then the new line message, this is where replace
            // formatting comes in to remove the special mc escape sequences
            let message = format!("[{}]{}\n", &server_name, reply);

            if message.contains("say `") || message.contains("say [") {
                continue;
            }

            fmessage.push_str(&message);
        }
    }

    if fmessage.len() > 0 {
        // send the message to the chat bridge channel
        if let Err(why) = ChannelId(chat_id).say(&ctx.http, fmessage).await {
            println!("Error sending message: {:?}", why);
        }
    }

    // if the lines are under 2k, we don't need to replace the file since it doesn't take much time
    // to process in the first place
    if lines < 2000 {
        return (cur_line, new_line);
    }

    // if it is above 2k however, we can reset the pipe and notify the to the console
    gen_pipe(server_name.to_owned(), true).await;
    println!("*info: pipe file reset -> {}", server_name);

    // return new line count to update the one in the main file
    (0, new_line)
}

pub fn collect(server: String, lines: u16) -> String {
    let path: String = format!("/tmp/{}-HypnosCore", server);

    if !check_dir(path.to_owned(), true) {
        return "".to_string();
    }

    let (file, fline) = (File::open(&path).unwrap(), File::open(&path).unwrap());
    let (reader, flines) = (
        BufReader::new(file).lines(),
        BufReader::new(fline).lines().count(),
    );

    if lines as usize > flines {
        return "INVALID".to_string();
    }

    let mut result = String::new();

    for (i, line) in reader.enumerate() {
        if i >= flines - lines as usize {
            let new_content = format!("{}\n", line.expect("failed to parse line in collect"));
            result.push_str(&new_content);
        }
    }

    result
}

// TODO
// fix disk usage
//

pub async fn sys_check(dis: bool, ctx: Context, msg: Option<Message>, chat_id: u64) {
    let (mut sys, mut warn) = (System::new_all(), false);
    sys.refresh_all();
    let mut response = String::new();

    // future, if first element < 100, it is the index of the disk that has problems
    let (u, t, i) = check_disk(&sys);

    // rustc is phasing out floats in match statements for obvious reasons, since we only need to check
    // for one value we can multiply this to get around it
    let x = (i * 100.0) as u16;
    if x != 10 {
        let drive = format!("drive low on space!:\nindex: {}\n", i);
        warn = true;
        response.push_str(&drive);
    }
    let drive = format!(
        "drive usage: {:.1} Mb /{:.1} Mb ({:.1}%)\n",
        u / 1048576.0,
        t / 1048576.0,
        (u / t) * 100.0
    );
    response.push_str(&drive);

    let ldavg = &sys.load_average().five;

    if ldavg > &0.0 {
        if ldavg > &(sys.physical_core_count().unwrap() as f64) {
            warn = true;
            response.push_str(&"high load average detected!\n");
        }
        // core count is only accurate if you have hyperthreading
        let avg = format!(
            "load average (5 minutes): {} -> {} logical cores\n",
            ldavg,
            sys.physical_core_count().unwrap() * 2
        );

        response.push_str(&avg);
    }

    if (sys.used_memory() as f64 / sys.total_memory() as f64) > 0.9 {
        response.push_str(&"high ram usage detected!\n");
        warn = true;
    }
    let ramu = format!(
        "ram usage: {} Mb / {} Mb ({:.2}%)\n",
        sys.used_memory() / 1045,
        sys.total_memory() / 1045,
        (sys.used_memory() as f64 / sys.total_memory() as f64) * 100.0
    );
    response.push_str(&ramu);

    let uptime = format!("server uptime: {} hrs\n", (sys.uptime() / 3600));

    response.push_str(&uptime);

    if warn {
        response.push_str("<@566444484850745351> unfuck plz");
        // send warn the message to the chat bridge channel
        if let Err(why) = ChannelId(chat_id).say(&ctx.http, &response).await {
            println!("Error sending message: {:?}", why);
        }
    }

    if dis && msg.is_some() {
        if let Err(why) = msg.unwrap().channel_id.say(&ctx.http, &response).await {
            println!("Error sending message: {:?}", why);
        }
    }
}

// check the disk space avaible on the server, overfilling a drive is never a good thing and having
// this automatically be checked every few minutes is quite nice
//
// the function returns the index of the drive if there is one in trouble, this can help quickly sort
// things out through df -h if needed
pub fn check_disk(sys: &System) -> (f64, f64, f64) {
    let (mut used_biggest, mut used_total) = (0.0, 0.0);
    let (mut warn_i, mut cur_i) = (0, 0);
    let mut warn: bool = false;
    for disk in sys.disks() {
        // check if the disk space is over 10 gig total, if it is smaller it could be a ramfs or
        // temp partition that we can ignore
        if disk.total_space() < 10737418240 {
            continue;
        }

        let total_space = disk.total_space() as f64;

        if total_space > used_total {
            used_total = total_space;
            used_biggest = disk.available_space() as f64;
        }

        if ((used_total - used_biggest) / disk.total_space() as f64) > 0.9 {
            warn = true;
            warn_i = cur_i;
            println!("*warn: drive space low on drive index: {}", warn_i);
        }

        cur_i += 1;
    }
    if warn {
        return (used_total - used_biggest, used_total, warn_i as f64);
    } else {
        return (used_total - used_biggest, used_total, 0.1);
    }
}

// evaluate strings as an expression, this does NOT allow rce or anything, it can do very basic
// math, it always sends the response to the chat bridge
//
// in the future I hope to replace this with my own parsing/eval since I can more reliably make
// this 'secure'
// not to insinuate that this is insecure or anything
pub async fn run_calc(ctx: Context, chat_id: u64, expression: String) {
    let result = eval(&expression);
    let mut response: String = String::new();
    // the crate allows the use of ranges to be evaluated, however, we will just ignore them as
    // they can cause issues if large ranges are used
    if result.is_err() || result.as_ref().ok().unwrap().to_string().contains("..") {
        response = "invalid expression".to_string();
    } else {
        if result.as_ref().ok().unwrap().to_string().len() > 200 {
            return;
        }
        response = format!("-> {}", &result.ok().unwrap());
    }
    if let Err(why) = ChannelId(chat_id).say(&ctx.http, response).await {
        println!("Error sending message: {:?}", why);
    }
}

extern "C" {
    pub fn waitpid(pid: pid_t, stat_loc: *mut c_int, options: c_int) -> pid_t;
}

// std::Command can leave behind zombie processes that buid up over time, this small function uses
// unsafe parts of libc but it reliably gets rid of any zombies that are left over
#[inline]
pub fn reap() {
    unsafe {
        waitpid(-1, std::ptr::null_mut(), 0x00000001);
    }
}

// tiny function to copy the default config to the current used
pub fn default_cfg(exit: bool) {
    if check_dir("./hypnos_core.conf".to_string(), false) {
        println!("*warn: replace config called but config exists, is this intended?");
        println!("*warn: if so, replace it");
        return;
    }
    copy("./src/default/template.conf", "./hypnos_core.conf")
        .expect("failed to copy default config, does it exists?");
    if exit {
        std::process::exit(0);
    }
}
